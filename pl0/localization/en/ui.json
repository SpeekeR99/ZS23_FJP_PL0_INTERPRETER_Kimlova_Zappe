{
    "title": "PL/0",
    "bntBack": "Step back",
    "btnForward": "Step forward",
    "btnPlay": "Run",
    "btnReset": "Reset",
    "headerInstructions": "Instructions",
    "headerStack": "Stack",
    "headerHeap": "Heap",
    "headerInput": "Input",
    "headerOutput": "Output",
    "headerWarnings": "Warnings",

    "notAllocated": "Not allocated",
    "notAllocatedMeta": "Not allocated, contains block metadata",
    "allocated": "Allocated",
    "allocatedMeta": "Allocated, contains block metadata",

    "heapCellIndex": "Index",
    "heapCellValue": "Value",

    "instructions": "Instructions",
    "value": "Value",
    "operation": "Operation",
    "address": "Address",
    "level": "Level",
    "parameter": "Parameter",
    "help_lit": "Pushes value to the top of the stack.",
    "help_int": "Increases or decreases the stack pointer. Increasing beyond already generated stack creates 0s. Cannot decrease stack pointer under the current stack frame or under -1.",
    "help_opr": "Performs operation (logic or arithmetic). The instruction behaves just like the referece interpreter (operations 1 - 13). If the operation uses two values from stack, the first value is the one with the lower index and the second value is the one on top of the stack.",
    "help_opr2": "Available operations:\n1 - Unary minus\n2 - Addition\n3 - Subtraction\n4 - Multiplication\n5 - Division\n6 - Modulo\n7 - Is odd\n8 - Equal\n9 - Not equal\n10 - Less than\n11 - More or equal than\n12 - More than\n13 - Less or equal than",
    "help_jmp": "Jumps to the instruction specified by address. If the jump would end up on a non-existent instruction, an exception is thrown.",
    "help_jmc": "If there is 0 on the top of the stack, jumps to the instruction specified by the address. If the jump would end up on a non-existent instruction, an exception is thrown.",
    "help_lod": "Loads a value from level, address on the stack and pushes it into the stack. If the level is too high (the target stack frame would end up under the first stack frame) an exception is thrown.",
    "help_sto": "Stores the value on top of the stack to level, address on stack. If the level is too high (the target stack frame would end up under the first stack frame) an exception is thrown.",
    "help_cal": "Creates a new stack frame with static base (SB) at relative index 0, dynamic base (DB) at relative index 1 and program counter (PC) at relative index 2.",
    "help_cal2": "The static base is set levels down, so when the level is 0, the static base is set as the caller's current base, and when the level is 1 the static base is set as the current caller's static base. Otherwise, the static base is resolved by iterating over the static bases of the stack frames under the caller.",
    "help_cal3": "The dynamic base is set as the caller's current base. The program counter is set as the next instruction to be executed (PC + 1).",
    "help_cal4": "Then a jump is done to the instruction specified by address. The stack pointer has to be increased through the INT instruction (same as the reference interpreter).",
    "help_ret": "Sets the program counter (PC) to the value stored on the stack frame's index 2. Sets the stack pointer to current base - 1 (the top of previous stack frame). Sets the current base to the dynamic base (DB) stored on the stack frame's index 1.",
    "help_ret2": "If the instruction is executed while the current base is 0 (aka the first stack frame), the program exits.",
    "help_rea": "Reads one character from the input field, converts it to a number and pushes it into the stack. The character is expected to be ASCII (or Extended ASCII, simply 8 byte value). If there is no character in the input field or the character is not Extended ASCII character, an exception is thrown.",
    "help_wri": "Writes the value from the top of the stack into the output field as a character. If the value is not in range <0, 255>, an exception is thrown.",
    "help_new": "Takes the value on top of the stack as the number of heap cells to allocate. Allocates that many cells continuously (in one continuous block) and pushes the address of the block onto the stack. If the cells cannot be allocated, -1 is pushed onto the stack (e.g. not enough free cells, invalid value).",
    "help_del": "Takes the value on top of the stack as the address of the heap block to deallocate. The heap block is deallocated in its entirety. On failure throws an exception.",
    "help_lda": "Takes the value on top of the stack as the address of the heap cell. Pushes the value in the heap cell onto the stack. Throws an exception on failure.",
    "help_sta": "Takes the value on top of the stack as the value to store and the value under it (SP - 1) as the address to store it at. Stores the value at the address in heap. On failure throws an exception.",
    "help_pld": "Essentially a dynamic LOD, where the address is the value on top of the stack and the level is the value under it (SP - 1). Pushes the value from specified address and level of the stack onto the stack.",
    "help_pst": "Essentially a dynamic STO, where the address is the value on top of the stack, the level is the value under it (SP - 1) and the value to be stored is on the index SP - 2. Stores the specified value into the specified address and level of the stack.",
    "help_itr": "Takes two values from the top of the stack and understands them as two parts of decimal number. The number under the top of the stack (SP - 1) is the integer part and the number on top of the stack is the fractional part. Pushes mantissa and exponent in the base of 10 onto the stack (mantissa * 10^exponent). Mantissa will be on top of the stack and exponent under it.",
    "help_rti": "Takes two values from the top of the stack and understands them as mantissa and exponent in the base of 10. The number on top of the stack is the mantissa and the number under the top of the stack (SP - 1) is the exponent. Pushes two integers onto the stack, which can be understood as the integer and fractional part of the decimal number. Fractional part will be on top of the stack and integer part under it.",
    "help_rti2": "Parameter can either be 0 or 1. If it is 1, the number will be stripped of its fractional part and the integer part will be the only part pushed to the stack. With parameter set to 0 this instruction works as said above.",
    "help_opf": "Performs operation (logic or arithmetic). The instruction behaves just like the referece interpreter (operations 1 - 13). The only difference between OPR and OPF is that OPF uses floating points, so the operations take four values from the stack (two for each operand - mantissa and exponent).",
    "instructionsParsingState": "Instructions parsing",
    "instructionsValidationState": "Instructions validation",
    "inputFileLoaded": "Instructions file successfully loaded",
    "inputFileError": "Could not process input file.",
    "inputFileErrorNotText": "Could not process input file. Only text files are allowed",
    "cannotsaveNoInstructions": "No valid instructions found, can not save.",
    "btnLoadInstructions": "Load/Edit instructions",
    "instructionsModalHeader": "Load/Edit instructions",
    "btnSave": "Save",
    "btnCancel": "Cancel",

    "instructionsTableInstruction": "Instruction",
    "instructionsTableLevel": "Level",
    "instructionsTablePar": "Par",
    "instructionsTableExplanation": "Explanation",

    "stackSP": "SP",
    "stackBase": "Base",
    "stackSPSeparator": "Stack pointer delimiter",

    "stackSB": "Caller static base",
    "stackDB": "Caller dynamic base",
    "stackPC": "Caller program counter",

    "help": "Help",
    "ok": "Ok",

    "createdBy": "Created by Lukáš Vlček and Vojtěch Bartička, upgraded by Vladimíra Kimlová and Dominik Zappe",
    "workInfo": "Semestral work for KIV/FJP, FAV ZČU 2021 - 2023"
}
